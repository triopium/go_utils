!_TAG_EXTRA_DESCRIPTION	anonymous	/Include tags for non-named objects like lambda/
!_TAG_EXTRA_DESCRIPTION	fileScope	/Include tags of file scope/
!_TAG_EXTRA_DESCRIPTION	pseudo	/Include pseudo tags/
!_TAG_EXTRA_DESCRIPTION	subparser	/Include tags generated by subparsers/
!_TAG_FIELD_DESCRIPTION	epoch	/the last modified time of the input file (only for F\/file kind tag)/
!_TAG_FIELD_DESCRIPTION	file	/File-restricted scoping/
!_TAG_FIELD_DESCRIPTION	input	/input file/
!_TAG_FIELD_DESCRIPTION	name	/tag name/
!_TAG_FIELD_DESCRIPTION	pattern	/pattern/
!_TAG_FIELD_DESCRIPTION	typeref	/Type and name of a variable or typedef/
!_TAG_FIELD_DESCRIPTION!Go	package	/the real package specified by the package name/
!_TAG_FIELD_DESCRIPTION!Go	packageName	/the name for referring the package/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_KIND_DESCRIPTION!DTD	E,entity	/entities/
!_TAG_KIND_DESCRIPTION!DTD	a,attribute	/attributes/
!_TAG_KIND_DESCRIPTION!DTD	e,element	/elements/
!_TAG_KIND_DESCRIPTION!DTD	n,notation	/notations/
!_TAG_KIND_DESCRIPTION!DTD	p,parameterEntity	/parameter entities/
!_TAG_KIND_DESCRIPTION!Go	M,anonMember	/struct anonymous members/
!_TAG_KIND_DESCRIPTION!Go	P,packageName	/name for specifying imported package/
!_TAG_KIND_DESCRIPTION!Go	Y,unknown	/unknown/
!_TAG_KIND_DESCRIPTION!Go	a,talias	/type aliases/
!_TAG_KIND_DESCRIPTION!Go	c,const	/constants/
!_TAG_KIND_DESCRIPTION!Go	f,func	/functions/
!_TAG_KIND_DESCRIPTION!Go	i,interface	/interfaces/
!_TAG_KIND_DESCRIPTION!Go	m,member	/struct members/
!_TAG_KIND_DESCRIPTION!Go	n,methodSpec	/interface method specification/
!_TAG_KIND_DESCRIPTION!Go	p,package	/packages/
!_TAG_KIND_DESCRIPTION!Go	s,struct	/structs/
!_TAG_KIND_DESCRIPTION!Go	t,type	/types/
!_TAG_KIND_DESCRIPTION!Go	v,var	/variables/
!_TAG_KIND_DESCRIPTION!Markdown	S,subsection	/level 2 sections/
!_TAG_KIND_DESCRIPTION!Markdown	T,l4subsection	/level 4 sections/
!_TAG_KIND_DESCRIPTION!Markdown	c,chapter	/chapters/
!_TAG_KIND_DESCRIPTION!Markdown	h,hashtag	/hashtags/
!_TAG_KIND_DESCRIPTION!Markdown	n,footnote	/footnotes/
!_TAG_KIND_DESCRIPTION!Markdown	s,section	/sections/
!_TAG_KIND_DESCRIPTION!Markdown	t,subsubsection	/level 3 sections/
!_TAG_KIND_DESCRIPTION!Markdown	u,l5subsection	/level 5 sections/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_OUTPUT_VERSION	1.1	/current.age/
!_TAG_PARSER_VERSION!DTD	0.0	/current.age/
!_TAG_PARSER_VERSION!Go	0.0	/current.age/
!_TAG_PARSER_VERSION!Markdown	1.1	/current.age/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/jk/runs/golang/go2023/go_utils/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	6.2.0	/v6.2.0/
!_TAG_ROLE_DESCRIPTION!DTD!element	attOwner	/attributes owner/
!_TAG_ROLE_DESCRIPTION!DTD!parameterEntity	condition	/conditions/
!_TAG_ROLE_DESCRIPTION!DTD!parameterEntity	elementName	/element names/
!_TAG_ROLE_DESCRIPTION!DTD!parameterEntity	partOfAttDef	/part of attribute definition/
!_TAG_ROLE_DESCRIPTION!Go!package	imported	/imported package/
!_TAG_ROLE_DESCRIPTION!Go!unknown	receiverType	/receiver type/
2024-10-19	TODO.md	/^## 2024-10-19$/;"	s	chapter:TODO
Add	pkg/helper/erragregate.go	/^func (er *Errw) Add(err error, params ...any) {$/;"	f	struct:helper.Errw
Add	pkg/helper/errmap.go	/^func (em ErrMap) Add(errMain error, errorsPartial ...error) bool {$/;"	f	type:helper.ErrMap	typeref:typename:bool
AddMethod	pkg/helper/generic.go	/^func (f *Fopt) AddMethod(fu any) {$/;"	f	struct:helper.Fopt
AddOption	pkg/configure/config_map.go	/^func (cc *CommandConfig) AddOption($/;"	f	struct:configure.CommandConfig
AddOption	pkg/configure/config_option_add.go	/^func (cc *CommanderConfig) AddOption($/;"	f	unknown:configure.CommanderConfig
AddOptionSimple	pkg/configure/config_option_add.go	/^func (cc *CommanderConfig) AddOptionSimple(o any) {$/;"	f	unknown:configure.CommanderConfig
AddSub	pkg/configure/config_map.go	/^func (cc *CommandConfig) AddSub(subName string, subF func()) {$/;"	f	struct:configure.CommandConfig
AddSub	pkg/configure/config_mapany.go	/^func (cc *CommanderConfig) AddSub(subName string, subF func()) {$/;"	f	struct:configure.CommanderConfig
Aggregate	pkg/helper/errmap.go	/^func (em ErrMap) Aggregate(errMain error, msgs ...string) bool {$/;"	f	type:helper.ErrMap	typeref:typename:bool
AllovedNames	test/pkg/configure_mapany/cmd/dummy.go	/^func AllovedNames(input []string) (bool, error) {$/;"	f	package:cmd	typeref:typename:(bool, error)
AllovedValues	pkg/configure/config_map.go	/^	AllovedValues []any$/;"	m	struct:configure.FlagOption	typeref:typename:[]any
BaseErr	pkg/helper/erragregate.go	/^	BaseErr          error$/;"	m	struct:helper.Errw	typeref:typename:error
BinName	pkg/configure/config_mapany.go	/^	BinName       string$/;"	m	struct:configure.CommanderConfig	typeref:typename:string
Break	pkg/helper/errors.go	/^	Break$/;"	c	package:helper
BuildBuildTime	test/pkg/configure_map/cmd/root.go	/^	BuildBuildTime string$/;"	v	package:cmd	typeref:typename:string
BuildBuildTime	test/pkg/configure_mapany/cmd/root.go	/^	BuildBuildTime string$/;"	v	package:cmd	typeref:typename:string
BuildGitCommit	test/pkg/configure_map/cmd/root.go	/^	BuildGitCommit string$/;"	v	package:cmd	typeref:typename:string
BuildGitCommit	test/pkg/configure_mapany/cmd/root.go	/^	BuildGitCommit string$/;"	v	package:cmd	typeref:typename:string
BuildGitTag	test/pkg/configure_map/cmd/root.go	/^	BuildGitTag    string$/;"	v	package:cmd	typeref:typename:string
BuildGitTag	test/pkg/configure_mapany/cmd/root.go	/^	BuildGitTag    string$/;"	v	package:cmd	typeref:typename:string
BuildTime	pkg/configure/common.go	/^	BuildTime   string$/;"	m	struct:configure.VersionInfo	typeref:typename:string
BuildTime	pkg/helper/helper.go	/^	BuildTime string$/;"	m	struct:helper.VersionInfo	typeref:typename:string
CSVcompareRows	pkg/files/csv.go	/^func CSVcompareRows(fileName1, fileName2 string) {$/;"	f	package:files
CSVdirToXLSX	pkg/files/csv.go	/^func CSVdirToXLSX(csvFolder string, csvDelim rune) error {$/;"	f	package:files	typeref:typename:error
CSVreadRows	pkg/files/csv.go	/^func CSVreadRows(csvFileName string, csvDelim rune) ([][]string, error) {$/;"	f	package:files	typeref:typename:([][]string, error)
CSVtoXLSX	pkg/files/csv.go	/^func CSVtoXLSX(csvFile string, csvDelim rune) error {$/;"	f	package:files	typeref:typename:error
CharEncoding	pkg/helper/file.go	/^type CharEncoding string$/;"	t	package:helper	typeref:typename:string
CharEncodingMap	pkg/helper/file.go	/^var CharEncodingMap = map[CharEncoding]EncodingHandler{$/;"	v	package:helper
CharEncodingUTF16be	pkg/helper/file.go	/^	CharEncodingUTF16be CharEncoding = "UTF16be"$/;"	c	package:helper	typeref:type:CharEncoding
CharEncodingUTF16le	pkg/helper/file.go	/^	CharEncodingUTF16le CharEncoding = "UTF16le"$/;"	c	package:helper	typeref:type:CharEncoding
CharEncodingUTF8	pkg/helper/file.go	/^	CharEncodingUTF8    CharEncoding = "UTF8"$/;"	c	package:helper	typeref:type:CharEncoding
Check	pkg/helper/generic.go	/^func (s *MyConfig[T]) Check($/;"	f	unknown:helper.T	typeref:typename:error
CheckAlloved	pkg/configure/config_mapany.go	/^func (ch *CheckerUntyped[T]) CheckAlloved(opt, inp any) {$/;"	f	unknown:configure.T
CheckAlloved	pkg/configure/config_mapany.go	/^func (ch *Checker[T]) CheckAlloved(opt string, inp any) {$/;"	f	unknown:configure.T
CheckAllovedVals	pkg/configure/config_mapany.go	/^func CheckAllovedVals($/;"	f	package:configure	typeref:typename:(bool, error)
CheckAllovedValues	pkg/configure/config_map.go	/^func CheckAllovedValues($/;"	f	package:configure
CheckIfFlagAlreadyDefined	pkg/configure/config_option_flag.go	/^func CheckIfFlagAlreadyDefined() {$/;"	f	package:configure
CheckInt	pkg/helper/generic.go	/^func CheckInt(in int) (bool, error) {$/;"	f	package:helper	typeref:typename:(bool, error)
Checker	pkg/configure/config_mapany.go	/^type Checker[T comparable] struct {$/;"	t	package:configure	typeref:typename:[T comparable] struct { AllovedVals any; AllovedFunc any;}
CheckerUntyped	pkg/configure/config_mapany.go	/^type CheckerUntyped[T any] struct {$/;"	t	package:configure	typeref:typename:[T any] struct { AllovedVals any; AllovedFunc any;}
CheckujAlloved	pkg/helper/generic.go	/^func (o *Opt[T]) CheckujAlloved(input T, aFunc func(T) (bool, error)) {$/;"	f	unknown:helper.T
ChooseFunction	test/pkg/configure_map/cmd/dummy.go	/^func ChooseFunction(in any) bool {$/;"	f	package:cmd	typeref:typename:bool
ChooseFunction	test/pkg/configure_mapany/cmd/dummy.go	/^func ChooseFunction(in any) bool {$/;"	f	package:cmd	typeref:typename:bool
ChoseFunc	test/pkg/configure_map/cmd/dummy.go	/^	ChoseFunc       string$/;"	m	struct:cmd.commandDummyVars	typeref:typename:string
ChoseVar	test/pkg/configure_map/cmd/dummy.go	/^	ChoseVar        string$/;"	m	struct:cmd.commandDummyVars	typeref:typename:string
CleanuUP	pkg/helper/tester.go	/^func (tc *TesterConfig) CleanuUP() {$/;"	f	struct:helper.TesterConfig
CodeMsg	pkg/helper/errors.go	/^func (ecm ErrorsCodeMap) CodeMsg(code ErrorCode) string {$/;"	f	type:helper.ErrorsCodeMap	typeref:typename:string
ColumnHeader	pkg/files/xlsx.go	/^	ColumnHeader         []string$/;"	m	struct:files.Table	typeref:typename:[]string
ColumnHeaderMap	pkg/files/xlsx.go	/^	ColumnHeaderMap      map[string]int$/;"	m	struct:files.Table	typeref:typename:map[string]int
CommandConfig	pkg/configure/config_map.go	/^type CommandConfig struct {$/;"	s	package:configure
CommandConstruct	pkg/configure/config_mapany.go	/^func CommandConstruct(flags string) string {$/;"	f	package:configure	typeref:typename:string
CommandRoot	pkg/configure/config_map.go	/^var CommandRoot = CommandConfig{$/;"	v	package:configure
CommandRootRun	test/pkg/configure_map/cmd/root.go	/^func CommandRootRun() {$/;"	f	package:cmd
CommandRootRun	test/pkg/configure_mapany/cmd/root.go	/^func CommandRootRun() {$/;"	f	package:cmd
CommanderConfig	pkg/configure/config_mapany.go	/^type CommanderConfig struct {$/;"	s	package:configure
CommanderRoot	pkg/configure/config_mapany.go	/^var CommanderRoot = CommanderConfig{$/;"	v	package:configure
CommonOpts	pkg/configure/populate4.go	/^type CommonOpts struct {$/;"	s	package:configure
Continue	pkg/helper/errors.go	/^	Continue ControlFlowAction = iota$/;"	c	package:helper	typeref:type:ControlFlowAction
ControlFlowAction	pkg/helper/errors.go	/^type ControlFlowAction int$/;"	t	package:helper	typeref:typename:int
CopyFields	pkg/configure/config_struct.go	/^func CopyFields(a interface{}, b interface{}) {$/;"	f	package:configure
CopyFile	pkg/helper/file.go	/^func CopyFile($/;"	f	package:helper	typeref:typename:error
Count	pkg/helper/erragregate.go	/^	Count            int$/;"	m	struct:helper.Errw	typeref:typename:int
Count	test/pkg/configure_mapany/cmd/dummy.go	/^	Count                  int$/;"	m	struct:cmd.commandDummyVars	typeref:typename:int
CreateTable	pkg/files/xlsx.go	/^func CreateTable(rows [][]string,$/;"	f	package:files	typeref:typename:*Table
CreateTableB	pkg/files/xlsx.go	/^func CreateTableB(rows [][]string,$/;"	f	package:files	typeref:typename:*Table
CreateTableTransformRowHeader	pkg/files/xlsx.go	/^func CreateTableTransformRowHeader(rows [][]string,$/;"	f	package:files	typeref:typename:*Table
CzechDateToUTC	pkg/helper/time.go	/^func CzechDateToUTC(year, month, day, hour int) ($/;"	f	package:helper	typeref:typename:(time.Time, error)
DateCreate	pkg/helper/time.go	/^func DateCreate(location *time.Location, specs ...int) time.Time {$/;"	f	package:helper	typeref:typename:time.Time
DateCurrentLocal	pkg/helper/time.go	/^func DateCurrentLocal() time.Time {$/;"	f	package:helper	typeref:typename:time.Time
DateFrom	test/pkg/configure_map/cmd/dummy.go	/^	DateFrom        time.Time$/;"	m	struct:cmd.commandDummyVars	typeref:typename:time.Time
DateFrom	test/pkg/configure_mapany/cmd/dummy.go	/^	DateFrom               time.Time$/;"	m	struct:cmd.commandDummyVars	typeref:typename:time.Time
DateInRange	pkg/helper/time.go	/^func DateInRange(interval [2]time.Time, dateToCheck time.Time) bool {$/;"	f	package:helper	typeref:typename:bool
DateRangesIntersection	pkg/helper/time.go	/^func DateRangesIntersection(rA, rB [2]time.Time) ([2]time.Time, bool) {$/;"	f	package:helper	typeref:typename:([2]time.Time, bool)
DebugConfig	pkg/configure/config_map.go	/^	DebugConfig bool$/;"	m	struct:configure.RootCfg	typeref:typename:bool
DebugConfig	pkg/configure/config_mapany.go	/^	DebugConfig bool$/;"	m	struct:configure.RootConfig	typeref:typename:bool
DeclareFlag	pkg/configure/config_map.go	/^func (opt *FlagOption) DeclareFlag() [6]interface{} {$/;"	f	struct:configure.FlagOption	typeref:typename:[6]interface{}
DeclareFlagHandle	pkg/configure/config_option_flag.go	/^func DeclareFlagHandle[T any]($/;"	f	package:configure	typeref:typename:(s interface{}, myMap map[string][6]interface{})
DeclareFlags	pkg/configure/config_map.go	/^func (cc *CommandConfig) DeclareFlags() {$/;"	f	struct:configure.CommandConfig
DeclareFlags	pkg/configure/config_mapany.go	/^func (cc *CommanderConfig) DeclareFlags() {$/;"	f	struct:configure.CommanderConfig
DeclareFlags	pkg/configure/config_struct.go	/^func DeclareFlags(config interface{}) (FlagsMap, error) {$/;"	f	package:configure	typeref:typename:(FlagsMap, error)
DeclareUsage	pkg/configure/config_map.go	/^func (opt *FlagOption) DeclareUsage() {$/;"	f	struct:configure.FlagOption
DeclareUsage	pkg/configure/config_mapany.go	/^func (o *Opt[T]) DeclareUsage() {$/;"	f	unknown:configure.T
Default	pkg/configure/config_map.go	/^	Default    string$/;"	m	struct:configure.FlagDescription	typeref:typename:string
Default	pkg/configure/config_mapany.go	/^	Default   string$/;"	m	struct:configure.OptDesc	typeref:typename:string
Descripton	pkg/configure/config_map.go	/^	Descripton string$/;"	m	struct:configure.FlagDescription	typeref:typename:string
DirectoryCopy	pkg/helper/directory.go	/^func DirectoryCopy($/;"	f	package:helper	typeref:typename:error
DirectoryCreateInRam	pkg/helper/directory.go	/^func DirectoryCreateInRam(base_name string) string {$/;"	f	package:helper	typeref:typename:string
DirectoryCreateTemporaryOrPanic	pkg/helper/directory.go	/^func DirectoryCreateTemporaryOrPanic(baseDirName string) string {$/;"	f	package:helper	typeref:typename:string
DirectoryDeleteOrPanic	pkg/helper/directory.go	/^func DirectoryDeleteOrPanic(directory string) {$/;"	f	package:helper
DirectoryExists	pkg/helper/directory.go	/^func DirectoryExists(fileSystemPath string) (bool, error) {$/;"	f	package:helper	typeref:typename:(bool, error)
DirectoryIsReadableOrPanic	pkg/helper/directory.go	/^func DirectoryIsReadableOrPanic(fileSystemPath string) {$/;"	f	package:helper
DirectoryTraverse	pkg/helper/directory.go	/^func DirectoryTraverse($/;"	f	package:helper	typeref:typename:error
DryRun	pkg/configure/config_map.go	/^	DryRun      bool$/;"	m	struct:configure.RootCfg	typeref:typename:bool
DryRun	pkg/configure/config_mapany.go	/^	DryRun      bool$/;"	m	struct:configure.RootConfig	typeref:typename:bool
EncodingHandler	pkg/helper/file.go	/^type EncodingHandler struct {$/;"	s	package:helper
ErrCodeClosed	pkg/helper/errors.go	/^	ErrCodeClosed$/;"	c	package:helper
ErrCodeDataFormat	pkg/helper/errors.go	/^	ErrCodeDataFormat$/;"	c	package:helper
ErrCodeExist	pkg/helper/errors.go	/^	ErrCodeExist$/;"	c	package:helper
ErrCodeInvalid	pkg/helper/errors.go	/^	ErrCodeInvalid$/;"	c	package:helper
ErrCodeInvalidCommand	pkg/helper/errors.go	/^	ErrCodeInvalidCommand ErrorCode = 1$/;"	c	package:helper	typeref:type:ErrorCode
ErrCodeNotExist	pkg/helper/errors.go	/^	ErrCodeNotExist$/;"	c	package:helper
ErrCodeParseField	pkg/helper/errors.go	/^	ErrCodeParseField$/;"	c	package:helper
ErrCodeParseXML	pkg/helper/errors.go	/^	ErrCodeParseXML$/;"	c	package:helper
ErrCodePermission	pkg/helper/errors.go	/^	ErrCodePermission     ErrorCode = 2 + iota$/;"	c	package:helper	typeref:type:ErrorCode
ErrCodeSuccess	pkg/helper/errors.go	/^	ErrCodeSuccess        ErrorCode = 0$/;"	c	package:helper	typeref:type:ErrorCode
ErrCodeUnknown	pkg/helper/errors.go	/^	ErrCodeUnknown$/;"	c	package:helper
ErrEncountered	pkg/helper/errors.go	/^	ErrEncountered$/;"	c	package:helper
ErrFileEncodingUnknown	pkg/helper/file.go	/^var ErrFileEncodingUnknown = errors.New("file encoding name is unknown")$/;"	v	package:helper
ErrFilePathExists	pkg/helper/file.go	/^var ErrFilePathExists = errors.New("file path exists")$/;"	v	package:helper
ErrList	pkg/helper/errlist.go	/^type ErrList struct {$/;"	s	package:helper
ErrMap	pkg/helper/errmap.go	/^type ErrMap map[string][]string$/;"	t	package:helper	typeref:typename:map[string][]string
Error	pkg/configure/config_map.go	/^func (opt FlagDescription) Error(err error) {$/;"	f	struct:configure.FlagDescription
Error	pkg/configure/config_mapany.go	/^func (o *Opt[T]) Error(err error) {$/;"	f	unknown:configure.T
ErrorAdd	pkg/helper/errlist.go	/^func (e *ErrList) ErrorAdd(err error) {$/;"	f	struct:helper.ErrList
ErrorAdd	pkg/helper/errors.go	/^func (ea *ErrorsAgregate) ErrorAdd(err error) {$/;"	f	struct:helper.ErrorsAgregate
ErrorAggregate	pkg/helper/erragregate.go	/^type ErrorAggregate map[string]int \/\/ function,line,count of errors$/;"	t	package:helper	typeref:typename:map[string]int
ErrorAppend	pkg/helper/errors.go	/^func ErrorAppend(errs []error, err error) []error {$/;"	f	package:helper	typeref:typename:[]error
ErrorBaseMessage	pkg/helper/errors.go	/^func (ecm ErrorsCodeMap) ErrorBaseMessage(err error) string {$/;"	f	type:helper.ErrorsCodeMap	typeref:typename:string
ErrorCode	pkg/helper/errors.go	/^func (ecm ErrorsCodeMap) ErrorCode(err error) ErrorCode {$/;"	f	type:helper.ErrorsCodeMap	typeref:typename:ErrorCode
ErrorCode	pkg/helper/errors.go	/^type ErrorCode int8$/;"	t	package:helper	typeref:typename:int8
ErrorRaise	pkg/helper/errlist.go	/^func (e *ErrList) ErrorRaise(err error) {$/;"	f	struct:helper.ErrList
ErrorWrap	pkg/helper/errors.go	/^func ErrorWrap(fieldName, fieldValue string, err error) error {$/;"	f	package:helper	typeref:typename:error
Errors	pkg/helper/errlist.go	/^	Errors []error$/;"	m	struct:helper.ErrList	typeref:typename:[]error
Errors	pkg/helper/errors.go	/^	Errors   []error$/;"	m	struct:helper.ErrorsAgregate	typeref:typename:[]error
Errors	pkg/helper/errors.go	/^var Errors ErrorsCodeMap = ErrorsCodeMap{$/;"	v	package:helper	typeref:type:ErrorsCodeMap
ErrorsAgregate	pkg/helper/errors.go	/^type ErrorsAgregate struct {$/;"	s	package:helper
ErrorsCodeMap	pkg/helper/errors.go	/^type ErrorsCodeMap map[ErrorCode]string$/;"	t	package:helper	typeref:typename:map[ErrorCode]string
ErrorsReturn	pkg/helper/erragregate.go	/^func (er *Errw) ErrorsReturn() error {$/;"	f	struct:helper.Errw	typeref:typename:error
ErrorsReturn	pkg/helper/errlist.go	/^func (e *ErrList) ErrorsReturn() error {$/;"	f	struct:helper.ErrList	typeref:typename:error
ErrorsReturnMap	pkg/helper/erragregate.go	/^func (er *Errw) ErrorsReturnMap() error {$/;"	f	struct:helper.Errw	typeref:typename:error
ErrsDetailsMap	pkg/helper/erragregate.go	/^	ErrsDetailsMap   map[string]any$/;"	m	struct:helper.Errw	typeref:typename:map[string]any
ErrsDetailsSlice	pkg/helper/erragregate.go	/^	ErrsDetailsSlice []any$/;"	m	struct:helper.Errw	typeref:typename:[]any
Errw	pkg/helper/erragregate.go	/^type Errw struct {$/;"	s	package:helper
EscapeCSVdelim	pkg/helper/string.go	/^func EscapeCSVdelim(value string) string {$/;"	f	package:helper	typeref:typename:string
EscapeCSVdelimB	pkg/helper/string.go	/^func EscapeCSVdelimB(value string) string {$/;"	f	package:helper	typeref:typename:string
Example code to setup dummy subcommand with flags	test/pkg/configure_map/README.md	/^# Example code to setup dummy subcommand with flags$/;"	c
ExampleXMLrundown	pkg/files/xml_test.go	/^var ExampleXMLrundown = `<?xml version="1.0" encoding="utf-8" standalone="no"?>$/;"	v	package:files
ExampleXmlLevels	pkg/files/xml_test.go	/^var ExampleXmlLevels = `$/;"	v	package:files
ExitWithCode	pkg/helper/errors.go	/^func (ecm ErrorsCodeMap) ExitWithCode(err error) {$/;"	f	type:helper.ErrorsCodeMap
FileDirectoryExists	pkg/helper/directory.go	/^func FileDirectoryExists(filePath string) (bool, error) {$/;"	f	package:helper	typeref:typename:(bool, error)
FileExists	pkg/helper/file.go	/^func FileExists(filePath string) (bool, error) {$/;"	f	package:helper	typeref:typename:(bool, error)
FileGetReaderUTF16le	pkg/helper/file.go	/^func FileGetReaderUTF16le(reader io.Reader) io.Reader {$/;"	f	package:helper	typeref:typename:io.Reader
FileGetReaderUTF8	pkg/helper/file.go	/^func FileGetReaderUTF8(reader io.Reader) io.Reader {$/;"	f	package:helper	typeref:typename:io.Reader
FileName	test/pkg/configure_mapany/cmd/dummy.go	/^	FileName               string$/;"	m	struct:cmd.commandDummyVars	typeref:typename:string
FileOsEncoding	pkg/helper/file.go	/^func FileOsEncoding(file *os.File) (CharEncoding, error) {$/;"	f	package:helper	typeref:typename:(CharEncoding, error)
FilePathEncoding	pkg/helper/file.go	/^func FilePathEncoding(filePath string) (CharEncoding, error) {$/;"	f	package:helper	typeref:typename:(CharEncoding, error)
FilePathNewDestinationValid	pkg/helper/directory.go	/^func FilePathNewDestinationValid(filePath string) (bool, error) {$/;"	f	package:helper	typeref:typename:(bool, error)
FileReadAllHandleEncoding	pkg/helper/file.go	/^func FileReadAllHandleEncoding(filePath string) ($/;"	f	package:helper	typeref:typename:([]byte, CharEncoding, error)
FileReaderHandleEncoding	pkg/helper/file.go	/^func FileReaderHandleEncoding(filePath string) ($/;"	f	package:helper	typeref:typename:(io.Reader, *os.File, error)
FilenameWithoutExtension	pkg/helper/file.go	/^func FilenameWithoutExtension(filePath string) string {$/;"	f	package:helper	typeref:typename:string
FirstLetterToLowercase	pkg/helper/string.go	/^func FirstLetterToLowercase(input string) string {$/;"	f	package:helper	typeref:typename:string
FirstLetterToUppercase	pkg/helper/string.go	/^func FirstLetterToUppercase(input string) string {$/;"	f	package:helper	typeref:typename:string
FlagDescription	pkg/configure/config_map.go	/^	FlagDescription$/;"	M	struct:configure.FlagOption	typeref:typename:FlagDescription
FlagDescription	pkg/configure/config_map.go	/^type FlagDescription struct {$/;"	s	package:configure
FlagOption	pkg/configure/config_map.go	/^type FlagOption struct {$/;"	s	package:configure
FlagsDeclared	pkg/configure/config_mapany.go	/^	FlagsDeclared bool$/;"	m	struct:configure.CommanderConfig	typeref:typename:bool
FlagsMap	pkg/configure/config_struct.go	/^type FlagsMap map[string]map[string]interface{}$/;"	t	package:configure	typeref:typename:map[string]map[string]interface{}
FlagsUsage	pkg/configure/common.go	/^var FlagsUsage = ""$/;"	v	package:configure
Fopt	pkg/helper/generic.go	/^type Fopt struct {$/;"	s	package:helper
ForEachRemaining	pkg/helper/generic.go	/^func (s *MyStruct[T]) ForEachRemaining(action func(T) error) error {$/;"	f	unknown:helper.T	typeref:typename:error
ForEachRemaining	pkg/helper/generic.go	/^func (s MySlice[T]) ForEachRemaining(action func(T) error) error {$/;"	f	unknown:helper.T	typeref:typename:error
FuncMatch	pkg/configure/config_map.go	/^	FuncMatch func(any) bool$/;"	m	struct:configure.FlagOption	typeref:typename:func(any) bool
GeneralHelp	pkg/configure/config_mapany.go	/^	GeneralHelp bool$/;"	m	struct:configure.RootConfig	typeref:typename:bool
GetBoolValueByPriority	pkg/configure/common.go	/^func GetBoolValueByPriority($/;"	f	package:configure	typeref:typename:bool
GetBoolValuePriority	pkg/configure/common.go	/^func GetBoolValuePriority(vals ...bool) bool {$/;"	f	package:configure	typeref:typename:bool
GetCommand	pkg/configure/config_mapany.go	/^func GetCommand(flags string) string {$/;"	f	package:configure	typeref:typename:string
GetCommonPath	pkg/helper/helper.go	/^func GetCommonPath(filePath, relPath string) (string, error) {$/;"	f	package:helper	typeref:typename:(string, error)
GetError	pkg/helper/errors.go	/^func (ea *ErrorsAgregate) GetError() {$/;"	f	struct:helper.ErrorsAgregate
GetIntValueByPriority	pkg/configure/common.go	/^func GetIntValueByPriority($/;"	f	package:configure	typeref:typename:int
GetIntValuePriority	pkg/configure/common.go	/^func GetIntValuePriority(vals ...int) int {$/;"	f	package:configure	typeref:typename:int
GetMessage	pkg/helper/errors.go	/^func (ea *ErrorsAgregate) GetMessage() {$/;"	f	struct:helper.ErrorsAgregate
GetPackageName	pkg/helper/helper.go	/^func GetPackageName(object any) string {$/;"	f	package:helper	typeref:typename:string
GetStringValueByPriority	pkg/configure/common.go	/^func GetStringValueByPriority($/;"	f	package:configure	typeref:typename:string
GetStringValuePriority	pkg/configure/common.go	/^func GetStringValuePriority(vals ...string) string {$/;"	f	package:configure	typeref:typename:string
GirlNameOne	test/pkg/configure_mapany/cmd/dummy.go	/^	GirlNameOne            string$/;"	m	struct:cmd.commandDummyVars	typeref:typename:string
GirlNames	test/pkg/configure_mapany/cmd/dummy.go	/^	GirlNames              []string$/;"	m	struct:cmd.commandDummyVars	typeref:typename:[]string
GirlNamesAll	test/pkg/configure_mapany/cmd/dummy.go	/^	GirlNamesAll           []string$/;"	m	struct:cmd.commandDummyVars	typeref:typename:[]string
GirlNamesMap	test/pkg/configure_mapany/cmd/dummy.go	/^	GirlNamesMap           map[string]bool$/;"	m	struct:cmd.commandDummyVars	typeref:typename:map[string]bool
GirlNamesSpecific	test/pkg/configure_mapany/cmd/dummy.go	/^	GirlNamesSpecific      map[string]bool$/;"	m	struct:cmd.commandDummyVars	typeref:typename:map[string]bool
GitCommit	pkg/configure/common.go	/^	GitCommit   string$/;"	m	struct:configure.VersionInfo	typeref:typename:string
GitCommit	pkg/helper/helper.go	/^	GitCommit string$/;"	m	struct:helper.VersionInfo	typeref:typename:string
GitTag	pkg/configure/common.go	/^	GitTag      string$/;"	m	struct:configure.VersionInfo	typeref:typename:string
GitTag	pkg/helper/helper.go	/^	GitTag    string$/;"	m	struct:helper.VersionInfo	typeref:typename:string
Go Configure	README.md	/^## Go Configure$/;"	s	chapter:Go Utils
Go Helper	README.md	/^## Go Helper$/;"	s	chapter:Go Utils
Go Tester	README.md	/^## Go Tester$/;"	s	chapter:Go Utils
Go Utils	README.md	/^# Go Utils$/;"	c
Go workspace usage	README.md	/^### Go workspace usage$/;"	S	section:Go Utils""Go Helper
GoName	pkg/configure/config_mapany.go	/^	GoName        string$/;"	m	struct:configure.CommanderConfig	typeref:typename:string
Handle	pkg/helper/errlist.go	/^func (e *ErrList) Handle(result *error) {$/;"	f	struct:helper.ErrList
HandleFileEncoding	pkg/helper/file.go	/^func HandleFileEncoding($/;"	f	package:helper	typeref:typename:([]byte, error)
Helloer	pkg/helper/new.go	/^func Helloer() {$/;"	f	package:helper
Help	pkg/configure/config_mapany.go	/^	Help      string$/;"	m	struct:configure.OptDesc	typeref:typename:string
Help	pkg/configure/populate4.go	/^	Help    bool$/;"	m	struct:configure.CommonOpts	typeref:typename:bool
ISOweekStart	pkg/helper/time.go	/^func ISOweekStart(t time.Time, weeksOffset int) time.Time {$/;"	f	package:helper	typeref:typename:time.Time
ISOweekStartLocal	pkg/helper/time.go	/^func ISOweekStartLocal(weeks int) time.Time {$/;"	f	package:helper	typeref:typename:time.Time
Init	pkg/configure/config_map.go	/^func (cc *CommandConfig) Init() {$/;"	f	struct:configure.CommandConfig
Init	pkg/configure/config_mapany.go	/^func (cc *CommanderConfig) Init() {$/;"	f	struct:configure.CommanderConfig
InitMain	pkg/helper/tester.go	/^func (tc *TesterConfig) InitMain() {$/;"	f	struct:helper.TesterConfig
InitTempSrc	pkg/helper/tester.go	/^func (tc *TesterConfig) InitTempSrc($/;"	f	struct:helper.TesterConfig
InitTest	pkg/helper/tester.go	/^func (tc *TesterConfig) InitTest($/;"	f	struct:helper.TesterConfig
IsCurrentExecutableBinary	pkg/configure/config_mapany.go	/^func IsCurrentExecutableBinary() (string, bool) {$/;"	f	package:configure	typeref:typename:(string, bool)
IsOlderThanOneISOweek	pkg/helper/time.go	/^func IsOlderThanOneISOweek(dateToCheck, dateNow time.Time) bool {$/;"	f	package:helper	typeref:typename:bool
Iterator	pkg/helper/generic.go	/^type Iterator[T any] interface {$/;"	t	package:helper	typeref:typename:[T any] interface { ForEachRemaining(action func(T) error) error; }
JoinObjectPath	pkg/helper/string.go	/^func JoinObjectPath(oldpath, newpath string) string {$/;"	f	package:helper	typeref:typename:string
ListDirFiles	pkg/helper/directory.go	/^func ListDirFiles(dir string) ([]string, error) {$/;"	f	package:helper	typeref:typename:([]string, error)
LogTest	pkg/configure/config_mapany.go	/^	LogTest     bool$/;"	m	struct:configure.RootConfig	typeref:typename:bool
LogType	pkg/configure/config_map.go	/^	LogType     string$/;"	m	struct:configure.RootCfg	typeref:typename:string
LogType	pkg/configure/config_mapany.go	/^	LogType     string$/;"	m	struct:configure.RootConfig	typeref:typename:string
LoggingOutputTest	pkg/logging/sloger.go	/^func LoggingOutputTest() {$/;"	f	package:logging
LongFlag	pkg/configure/config_map.go	/^	LongFlag   string$/;"	m	struct:configure.FlagDescription	typeref:typename:string
LongFlag	pkg/configure/config_mapany.go	/^	LongFlag  string$/;"	m	struct:configure.OptDesc	typeref:typename:string
MapExcelSheetColumn	pkg/files/xlsx.go	/^func MapExcelSheetColumn($/;"	f	package:files	typeref:typename:(map[string]bool, error)
MapTableHeaders	pkg/files/xlsx.go	/^func (t *Table) MapTableHeaders($/;"	f	struct:files.Table
MapTableHeadersB	pkg/files/xlsx.go	/^func (t *Table) MapTableHeadersB($/;"	f	struct:files.Table
MapTableHeadersTransformColumn	pkg/files/xlsx.go	/^func (t *Table) MapTableHeadersTransformColumn($/;"	f	struct:files.Table
MapTableRowKeyTransform	pkg/files/xlsx.go	/^func (t *Table) MapTableRowKeyTransform($/;"	f	struct:files.Table
Marshal	pkg/helper/errmap.go	/^func (em ErrMap) Marshal() string {$/;"	f	type:helper.ErrMap	typeref:typename:string
MarshalError	pkg/helper/errmap.go	/^func (em ErrMap) MarshalError(errMsg string) error {$/;"	f	type:helper.ErrMap	typeref:typename:error
MatchRow	pkg/files/xlsx.go	/^func (t *Table) MatchRow($/;"	f	struct:files.Table	typeref:typename:bool
MaxUwrap	pkg/helper/erragregate.go	/^func (er *Errw) MaxUwrap(err error) (ret error) {$/;"	f	struct:helper.Errw	typeref:typename:(ret error)
MessageAdd	pkg/helper/errors.go	/^func (ea *ErrorsAgregate) MessageAdd(msg string) {$/;"	f	struct:helper.ErrorsAgregate
Messages	pkg/helper/errors.go	/^	Messages []string$/;"	m	struct:helper.ErrorsAgregate	typeref:typename:[]string
MessagesJoin	pkg/helper/errors.go	/^func (ea *ErrorsAgregate) MessagesJoin() string {$/;"	f	struct:helper.ErrorsAgregate	typeref:typename:string
Multiple	test/pkg/configure_map/cmd/dummy.go	/^	Multiple        []string$/;"	m	struct:cmd.commandDummyVars	typeref:typename:[]string
My	pkg/helper/generic.go	/^	My any$/;"	m	struct:helper.Fopt	typeref:typename:any
MyConfig	pkg/helper/generic.go	/^type MyConfig[T any] struct {$/;"	t	package:helper	typeref:typename:[T any] struct { }
MySlice	pkg/helper/generic.go	/^type MySlice[T any] []T$/;"	t	package:helper	typeref:typename:[T any] []T
MyStruct	pkg/helper/generic.go	/^type MyStruct[T any] struct{}$/;"	t	package:helper	typeref:typename:[T any] struct{}
NotNil	pkg/configure/config_mapany.go	/^	NotNil string = "NotNil"$/;"	c	package:configure	typeref:typename:string
NumberSlice	test/pkg/configure_mapany/cmd/dummy.go	/^	NumberSlice            []int$/;"	m	struct:cmd.commandDummyVars	typeref:typename:[]int
NumberSliceMap	test/pkg/configure_mapany/cmd/dummy.go	/^	NumberSliceMap         map[int]bool$/;"	m	struct:cmd.commandDummyVars	typeref:typename:map[int]bool
Opt	pkg/configure/config_mapany.go	/^type Opt[T any] struct {$/;"	t	package:configure	typeref:typename:[T any] struct { OptDesc; AllovedValues []T; FuncMatch func(v T) (bool, error);}
Opt	pkg/helper/generic.go	/^type Opt[T any] struct {$/;"	t	package:helper	typeref:typename:[T any] struct { Description string; FuncMatch func(v T) (bool, error);}
OptDesc	pkg/configure/config_mapany.go	/^type OptDesc struct {$/;"	s	package:configure
Opts	pkg/configure/config_map.go	/^	Opts        []FlagOption$/;"	m	struct:configure.CommandConfig	typeref:typename:[]FlagOption
Opts	pkg/configure/config_mapany.go	/^	Opts        []any$/;"	m	struct:configure.CommanderConfig	typeref:typename:[]any
OptsMap	pkg/configure/config_map.go	/^	OptsMap     map[string][6]interface{}$/;"	m	struct:configure.CommandConfig	typeref:typename:map[string][6]interface{}
OptsMap	pkg/configure/config_mapany.go	/^	OptsMap     map[string][6]interface{}$/;"	m	struct:configure.CommanderConfig	typeref:typename:map[string][6]interface{}
ParseFlag	pkg/configure/config_option_parse.go	/^func (cc *CommanderConfig) ParseFlag($/;"	f	unknown:configure.CommanderConfig	typeref:typename:error
ParseFlags	pkg/configure/config_map.go	/^func (cc *CommandConfig) ParseFlags(iface interface{}) error {$/;"	f	struct:configure.CommandConfig	typeref:typename:error
ParseFlags	pkg/configure/config_mapany.go	/^func (cc *CommanderConfig) ParseFlags(iface interface{}) error {$/;"	f	struct:configure.CommanderConfig	typeref:typename:error
ParseFlags	pkg/configure/config_struct.go	/^func (fm FlagsMap) ParseFlags() error {$/;"	f	type:configure.FlagsMap	typeref:typename:error
ParseStringDate	pkg/helper/time.go	/^func ParseStringDate(dateTime string, loc *time.Location) (time.Time, error) {$/;"	f	package:helper	typeref:typename:(time.Time, error)
PathExists	pkg/helper/directory.go	/^func PathExists(fileSystemPath string) (bool, error) {$/;"	f	package:helper	typeref:typename:(bool, error)
PopulateStruct	pkg/configure/populate4.go	/^func PopulateStruct(cfg interface{}) error {$/;"	f	package:configure	typeref:typename:error
PrintCommandExample	pkg/configure/config_mapany.go	/^func PrintCommandExample(goName, binName, flags string) {$/;"	f	package:configure
PrintHelpForAllCommands	pkg/configure/config_mapany.go	/^func (cc *CommanderConfig) PrintHelpForAllCommands($/;"	f	struct:configure.CommanderConfig
PrintManual	pkg/configure/config_mapany.go	/^func (cc *CommanderConfig) PrintManual() {$/;"	f	struct:configure.CommanderConfig
PrintMap	pkg/helper/string.go	/^func PrintMap(input map[string]map[string]string) {$/;"	f	package:helper
PrintObjectJson	pkg/helper/string.go	/^func PrintObjectJson(prefix string, input any) {$/;"	f	package:helper
PrintResult	pkg/helper/tester.go	/^func (tc *TesterConfig) PrintResult(a ...any) {$/;"	f	struct:helper.TesterConfig
ProcessedFileRename	pkg/helper/file.go	/^func ProcessedFileRename(originalPath string) error {$/;"	f	package:helper	typeref:typename:error
ProgramName	pkg/configure/common.go	/^	ProgramName string$/;"	m	struct:configure.VersionInfo	typeref:typename:string
ReadCSVfile	pkg/helper/file.go	/^func ReadCSVfile(filePath string) ([][]string, error) {$/;"	f	package:helper	typeref:typename:([][]string, error)
ReadCSVfileSep	pkg/helper/file.go	/^func ReadCSVfileSep(filePath string, sep rune) ([][]string, error) {$/;"	f	package:helper	typeref:typename:([][]string, error)
ReadExcelFileSheetRows	pkg/files/xlsx.go	/^func ReadExcelFileSheetRows(filePath, sheetName string) ($/;"	f	package:files	typeref:typename:(rows [][]string, err error)
ReaderFunc	pkg/helper/file.go	/^	ReaderFunc func(io.Reader) io.Reader$/;"	m	struct:helper.EncodingHandler	typeref:typename:func(io.Reader) io.Reader
RecoverPanic	pkg/helper/tester.go	/^func (tc *TesterConfig) RecoverPanic(t *testing.T) {$/;"	f	struct:helper.TesterConfig
RecoverPanicNoFail	pkg/helper/tester.go	/^func (tc *TesterConfig) RecoverPanicNoFail(t *testing.T) {$/;"	f	struct:helper.TesterConfig
Resume	test/pkg/configure_mapany/cmd/dummy.go	/^	Resume                 bool$/;"	m	struct:cmd.commandDummyVars	typeref:typename:bool
RootCfg	pkg/configure/config_map.go	/^type RootCfg struct {$/;"	s	package:configure
RootConfig	pkg/configure/config_mapany.go	/^	*RootConfig$/;"	M	struct:configure.CommanderConfig	typeref:typename:*RootConfig
RootConfig	pkg/configure/config_mapany.go	/^type RootConfig struct {$/;"	s	package:configure
RootFlagsAct	pkg/configure/config_mapany.go	/^func (cc *CommanderConfig) RootFlagsAct() {$/;"	f	struct:configure.CommanderConfig
RowHeaderToColumnMap	pkg/files/xlsx.go	/^	RowHeaderToColumnMap map[string][]string$/;"	m	struct:files.Table	typeref:typename:map[string][]string
Rows	pkg/files/xlsx.go	/^	Rows                 [][]string$/;"	m	struct:files.Table	typeref:typename:[][]string
RunCommandDummy	test/pkg/configure_map/cmd/dummy.go	/^func RunCommandDummy() {$/;"	f	package:cmd
RunCommandDummy	test/pkg/configure_mapany/cmd/dummy.go	/^func RunCommandDummy() {$/;"	f	package:cmd
RunRoot	pkg/configure/config_map.go	/^func (cc *CommandConfig) RunRoot() {$/;"	f	struct:configure.CommandConfig
RunRoot	pkg/configure/config_mapany.go	/^func (cc *CommanderConfig) RunRoot() {$/;"	f	struct:configure.CommanderConfig
RunSub	pkg/configure/config_map.go	/^func (cc *CommandConfig) RunSub(intf interface{}) {$/;"	f	struct:configure.CommandConfig
Runner	test/pkg/helper/errlist.go	/^func Runner() (res error) {$/;"	f	package:main	typeref:typename:(res error)
SetField	pkg/configure/config_struct.go	/^func SetField(rv reflect.Value, value any) error {$/;"	f	package:configure	typeref:typename:error
SetLogLevel	pkg/logging/sloger.go	/^func SetLogLevel(level string, logType ...string) {$/;"	f	package:logging
SetupRootFlags	pkg/configure/config_struct.go	/^func SetupRootFlags(config interface{}) {$/;"	f	package:configure
SetupSubFlags	pkg/configure/config_struct.go	/^func SetupSubFlags(config interface{}) {$/;"	f	package:configure
ShortFlag	pkg/configure/config_map.go	/^	ShortFlag  string$/;"	m	struct:configure.FlagDescription	typeref:typename:string
ShortFlag	pkg/configure/config_mapany.go	/^	ShortFlag string$/;"	m	struct:configure.OptDesc	typeref:typename:string
Skip	pkg/helper/errors.go	/^	Skip$/;"	c	package:helper
Sleeper	pkg/helper/time.go	/^func Sleeper(duration int, time_unit string) {$/;"	f	package:helper
SliceStringToMapInt	pkg/helper/slice.go	/^func SliceStringToMapInt(input []string) map[int]bool {$/;"	f	package:helper	typeref:typename:map[int]bool
SliceStringToMapString	pkg/helper/slice.go	/^func SliceStringToMapString(input []string) map[string]bool {$/;"	f	package:helper	typeref:typename:map[string]bool
SourceDirectory	test/pkg/configure_map/cmd/dummy.go	/^	SourceDirectory string$/;"	m	struct:cmd.commandDummyVars	typeref:typename:string
SourceDirectory	test/pkg/configure_mapany/cmd/dummy.go	/^	SourceDirectory        string$/;"	m	struct:cmd.commandDummyVars	typeref:typename:string
SourceDirectorySpecial	test/pkg/configure_mapany/cmd/dummy.go	/^	SourceDirectorySpecial string$/;"	m	struct:cmd.commandDummyVars	typeref:typename:string
Spec	pkg/configure/config_mapany.go	/^	Spec      string$/;"	m	struct:configure.OptDesc	typeref:typename:string
StringToIntSlice	pkg/helper/helper.go	/^func StringToIntSlice(slice, sep string) ([]int, error) {$/;"	f	package:helper	typeref:typename:([]int, error)
SubCommands	pkg/configure/config_mapany.go	/^type SubCommands map[string]func()$/;"	t	package:configure	typeref:typename:map[string]func()
SubErrsMap	pkg/helper/erragregate.go	/^	SubErrsMap       map[error]*Errw$/;"	m	struct:helper.Errw	typeref:typename:map[error]*Errw
SubErrsSlice	pkg/helper/erragregate.go	/^	SubErrsSlice     []*Errw$/;"	m	struct:helper.Errw	typeref:typename:[]*Errw
SubcommandOptionsParse	pkg/configure/config_mapany.go	/^func (cc *CommanderConfig) SubcommandOptionsParse(intf interface{}) {$/;"	f	struct:configure.CommanderConfig
Subcommander	pkg/configure/config_mapany.go	/^type Subcommander map[string]func()$/;"	t	package:configure	typeref:typename:map[string]func()
Subcommands	pkg/configure/config_map.go	/^type Subcommands map[string]func()$/;"	t	package:configure	typeref:typename:map[string]func()
Subs	pkg/configure/config_map.go	/^	Subs        Subcommands$/;"	m	struct:configure.CommandConfig	typeref:typename:Subcommands
Subs	pkg/configure/config_mapany.go	/^	Subs        SubCommands$/;"	m	struct:configure.CommanderConfig	typeref:typename:SubCommands
TODO	TODO.md	/^# TODO$/;"	c
Table	pkg/files/xlsx.go	/^type Table struct {$/;"	s	package:files
TempDataOutput	pkg/helper/tester.go	/^	TempDataOutput string$/;"	m	struct:helper.TesterConfig	typeref:typename:string
TempDataSource	pkg/helper/tester.go	/^	TempDataSource string$/;"	m	struct:helper.TesterConfig	typeref:typename:string
TempDestinationPathGeter	pkg/helper/tester.go	/^func (tc *TesterConfig) TempDestinationPathGeter(tempSubdir string) func(string) string {$/;"	f	struct:helper.TesterConfig	typeref:typename:func(string) string
TempDir	pkg/helper/tester.go	/^	TempDir        string$/;"	m	struct:helper.TesterConfig	typeref:typename:string
TempDirName	pkg/helper/tester.go	/^	TempDirName    string$/;"	m	struct:helper.TesterConfig	typeref:typename:string
TempSourcePathGeter	pkg/helper/tester.go	/^func (tc *TesterConfig) TempSourcePathGeter(tempSubdir string) func(string) string {$/;"	f	struct:helper.TesterConfig	typeref:typename:func(string) string
TestAABfail1	pkg/helper/tester_test.go	/^func TestAABfail1(t *testing.T) {$/;"	f	package:helper
TestAABfail2	pkg/helper/tester_test.go	/^func TestAABfail2(t *testing.T) {$/;"	f	package:helper
TestAABnofail1	pkg/helper/tester_test.go	/^func TestAABnofail1(t *testing.T) {$/;"	f	package:helper
TestAABnofail2	pkg/helper/tester_test.go	/^func TestAABnofail2(t *testing.T) {$/;"	f	package:helper
TestAAC1	pkg/helper/tester_test.go	/^func TestAAC1(t *testing.T) {$/;"	f	package:helper
TestAAC2	pkg/helper/tester_test.go	/^func TestAAC2(t *testing.T) {$/;"	f	package:helper
TestABSimple	pkg/helper/tester_test.go	/^func TestABSimple(t *testing.T) {$/;"	f	package:helper
TestCSVcompareRows	pkg/files/csv_test.go	/^func TestCSVcompareRows(t *testing.T) {$/;"	f	package:files
TestCSVdirToXLSX	pkg/files/csv_test.go	/^func TestCSVdirToXLSX(t *testing.T) {$/;"	f	package:files
TestCharEncoding	pkg/helper/file_test.go	/^func TestCharEncoding(t *testing.T) {$/;"	f	package:helper
TestCreateDirectory	pkg/helper/directory_test.go	/^func TestCreateDirectory(t *testing.T) {$/;"	f	package:helper
TestCreateTableTransformColumn	pkg/files/xlsx_test.go	/^func TestCreateTableTransformColumn(t *testing.T) {$/;"	f	package:files
TestCzechDateToUTC	pkg/helper/time_test.go	/^func TestCzechDateToUTC(t *testing.T) {$/;"	f	package:helper
TestDataSource	pkg/helper/tester.go	/^	TestDataSource string$/;"	m	struct:helper.TesterConfig	typeref:typename:string
TestDateGetUTC	pkg/helper/time_test.go	/^func TestDateGetUTC(t *testing.T) {$/;"	f	package:helper
TestDateRangesIntersection	pkg/helper/time_test.go	/^func TestDateRangesIntersection(t *testing.T) {$/;"	f	package:helper
TestDirectoryCreateTemporary	pkg/helper/directory_test.go	/^func TestDirectoryCreateTemporary(t *testing.T) {$/;"	f	package:helper
TestDirectoryExists	pkg/helper/directory_test.go	/^func TestDirectoryExists(t *testing.T) {$/;"	f	package:helper
TestErrJoin	pkg/helper/erragregate_test.go	/^func TestErrJoin(t *testing.T) {$/;"	f	package:helper
TestErrMap_Add	pkg/helper/errmap_test.go	/^func TestErrMap_Add(t *testing.T) {$/;"	f	package:helper
TestErrWrapped	pkg/helper/erragregate_test.go	/^func TestErrWrapped(t *testing.T) {$/;"	f	package:helper
TestErrorGetBaseMessage	pkg/helper/errors_test.go	/^func TestErrorGetBaseMessage(t *testing.T) {$/;"	f	package:helper
TestErrorGetCode	pkg/helper/errors_test.go	/^func TestErrorGetCode(t *testing.T) {$/;"	f	package:helper
TestErrw_Add	pkg/helper/erragregate_test.go	/^func TestErrw_Add(t *testing.T) {$/;"	f	package:helper
TestErrw_Wrap	pkg/helper/erragregate_test.go	/^func TestErrw_Wrap(t *testing.T) {$/;"	f	package:helper
TestEscapeCSVdelim	pkg/helper/string_test.go	/^func TestEscapeCSVdelim(t *testing.T) {$/;"	f	package:helper
TestEscapeCSVdelimB	pkg/helper/string_test.go	/^func TestEscapeCSVdelimB(t *testing.T) {$/;"	f	package:helper
TestFileExists	pkg/helper/file_test.go	/^func TestFileExists(t *testing.T) {$/;"	f	package:helper
TestFilePathEncoding	pkg/helper/file_test.go	/^func TestFilePathEncoding(t *testing.T) {$/;"	f	package:helper
TestFileReadAllHandleEncoding	pkg/helper/file_test.go	/^func TestFileReadAllHandleEncoding(t *testing.T) {$/;"	f	package:helper
TestGeneric	pkg/helper/generic_test.go	/^func TestGeneric(t *testing.T) {$/;"	f	package:helper
TestGeneric2	pkg/helper/generic_test.go	/^func TestGeneric2(t *testing.T) {$/;"	f	package:helper
TestGenericFunc	pkg/helper/generic_test.go	/^func TestGenericFunc(t *testing.T) {$/;"	f	package:helper
TestGenericFunc2	pkg/helper/generic_test.go	/^func TestGenericFunc2(t *testing.T) {$/;"	f	package:helper
TestGenericFunc3	pkg/helper/generic_test.go	/^func TestGenericFunc3(t *testing.T) {$/;"	f	package:helper
TestGenericFunc4	pkg/helper/generic_test.go	/^func TestGenericFunc4(t *testing.T) {$/;"	f	package:helper
TestGetUTCoffset	pkg/helper/time_test.go	/^func TestGetUTCoffset(t *testing.T) {$/;"	f	package:helper
TestISOweekStart	pkg/helper/time_test.go	/^func TestISOweekStart(t *testing.T) {$/;"	f	package:helper
TestIter	pkg/helper/helper_test.go	/^func TestIter(t *testing.T) {$/;"	f	package:helper
TestMain	pkg/helper/tester_test.go	/^func TestMain(m *testing.M) {$/;"	f	package:helper
TestMainCommand	test/pkg/configure_map/main_test.go	/^func TestMainCommand(t *testing.T) {$/;"	f	package:main
TestNodeGetParent	pkg/files/xml_test.go	/^func TestNodeGetParent(t *testing.T) {$/;"	f	package:files
TestPABC1	pkg/helper/tester_test.go	/^func TestPABC1(t *testing.T) {$/;"	f	package:helper
TestPABC2	pkg/helper/tester_test.go	/^func TestPABC2(t *testing.T) {$/;"	f	package:helper
TestParseStringDate	pkg/helper/time_test.go	/^func TestParseStringDate(t *testing.T) {$/;"	f	package:helper
TestPathExists	pkg/helper/directory_test.go	/^func TestPathExists(t *testing.T) {$/;"	f	package:helper
TestRegexp	pkg/helper/string_test.go	/^func TestRegexp(t *testing.T) {$/;"	f	package:helper
TestSlice	pkg/files/xlsx_test.go	/^func TestSlice(t *testing.T) {$/;"	f	package:files
TestSomething	pkg/helper/tester_test.go	/^func TestSomething(t *testing.T) {$/;"	f	package:helper
TestSomething2	pkg/helper/tester_test.go	/^func TestSomething2(t *testing.T) {$/;"	f	package:helper
TestTable_MapTableHeaders	pkg/files/xlsx_test.go	/^func TestTable_MapTableHeaders(t *testing.T) {$/;"	f	package:files
TestTempPathGeter	pkg/helper/tester_test.go	/^func TestTempPathGeter(t *testing.T) {$/;"	f	package:helper
TestWeek	pkg/helper/time_test.go	/^func TestWeek(t *testing.T) {$/;"	f	package:helper
TestXLSXtableBuild	pkg/files/xlsx_test.go	/^func TestXLSXtableBuild(t *testing.T) {$/;"	f	package:files
TestXLSXtableStreamSave	pkg/files/xlsx_test.go	/^func TestXLSXtableStreamSave(t *testing.T) {$/;"	f	package:files
TestXMLgetBaseNode	pkg/files/xml_test.go	/^func TestXMLgetBaseNode(t *testing.T) {$/;"	f	package:files
Test_CurrentDir	pkg/helper/directory_test.go	/^func Test_CurrentDir(t *testing.T) {$/;"	f	package:helper
Test_DirectoryCopy	pkg/helper/directory_test.go	/^func Test_DirectoryCopy(t *testing.T) {$/;"	f	package:helper
Test_DirectoryCreateInRam	pkg/helper/directory_test.go	/^func Test_DirectoryCreateInRam(t *testing.T) {$/;"	f	package:helper
Test_IsOlderThanOneISOweek	pkg/helper/time_test.go	/^func Test_IsOlderThanOneISOweek(t *testing.T) {$/;"	f	package:helper
Test_LogTraceFunction	pkg/helper/helper_test.go	/^func Test_LogTraceFunction(t *testing.T) {$/;"	f	package:helper
TesterConfig	pkg/helper/tester.go	/^type TesterConfig struct {$/;"	s	package:helper
TesterMain	pkg/helper/tester.go	/^func (tc *TesterConfig) TesterMain(m *testing.M) {$/;"	f	struct:helper.TesterConfig
TimeCurrent	pkg/helper/time.go	/^func TimeCurrent() string {$/;"	f	package:helper	typeref:typename:string
TimeUTClocalOffset	pkg/helper/time.go	/^func TimeUTClocalOffset(tm time.Time) time.Duration {$/;"	f	package:helper	typeref:typename:time.Duration
TraceFunction	pkg/helper/helper.go	/^func TraceFunction(depth int) (string, string, int) {$/;"	f	package:helper	typeref:typename:(string, string, int)
Type	pkg/configure/config_map.go	/^	Type       string$/;"	m	struct:configure.FlagDescription	typeref:typename:string
Type	pkg/configure/config_mapany.go	/^	Type      string$/;"	m	struct:configure.OptDesc	typeref:typename:string
UNUSED	pkg/helper/helper.go	/^func UNUSED(x ...interface{}) {}$/;"	f	package:helper
Usage	pkg/configure/common.go	/^func Usage() {$/;"	f	package:configure
Usage	pkg/configure/config_mapany.go	/^	Usage       bool$/;"	m	struct:configure.RootConfig	typeref:typename:bool
Values	pkg/configure/config_map.go	/^	Values      interface{}$/;"	m	struct:configure.CommandConfig	typeref:typename:interface{}
Values	pkg/configure/config_mapany.go	/^	Values      interface{}$/;"	m	struct:configure.CommanderConfig	typeref:typename:interface{}
Verbose	pkg/configure/config_map.go	/^	Verbose     int$/;"	m	struct:configure.RootCfg	typeref:typename:int
Verbose	pkg/configure/config_mapany.go	/^	Verbose     int$/;"	m	struct:configure.RootConfig	typeref:typename:int
Verbose	pkg/configure/populate4.go	/^	Verbose int$/;"	m	struct:configure.CommonOpts	typeref:typename:int
Version	pkg/configure/common.go	/^	Version     string$/;"	m	struct:configure.VersionInfo	typeref:typename:string
Version	pkg/configure/config_map.go	/^	Version     bool$/;"	m	struct:configure.RootCfg	typeref:typename:bool
Version	pkg/configure/config_mapany.go	/^	Version     bool$/;"	m	struct:configure.RootConfig	typeref:typename:bool
Version	pkg/helper/helper.go	/^	Version   string$/;"	m	struct:helper.VersionInfo	typeref:typename:string
VersionInfo	pkg/configure/common.go	/^type VersionInfo struct {$/;"	s	package:configure
VersionInfo	pkg/configure/config_map.go	/^	VersionInfo interface{}$/;"	m	struct:configure.CommandConfig	typeref:typename:interface{}
VersionInfo	pkg/configure/config_mapany.go	/^	VersionInfo interface{}$/;"	m	struct:configure.CommanderConfig	typeref:typename:interface{}
VersionInfo	pkg/helper/helper.go	/^type VersionInfo struct {$/;"	s	package:helper
VersionInfo	test/pkg/configure_map/cmd/root.go	/^var VersionInfo = configure.VersionInfo{$/;"	v	package:cmd
VersionInfo	test/pkg/configure_mapany/cmd/root.go	/^var VersionInfo = configure.VersionInfo{$/;"	v	package:cmd
VersionInfoAdd	pkg/configure/config_map.go	/^func (cc *CommandConfig) VersionInfoAdd(info interface{}) {$/;"	f	struct:configure.CommandConfig
VersionInfoAdd	pkg/configure/config_mapany.go	/^func (cc *CommanderConfig) VersionInfoAdd(info interface{}) {$/;"	f	struct:configure.CommanderConfig
VersionInfoPrint	pkg/configure/config_map.go	/^func (cc *CommandConfig) VersionInfoPrint() {$/;"	f	struct:configure.CommandConfig
VersionInfoPrint	pkg/configure/config_mapany.go	/^func (cc *CommanderConfig) VersionInfoPrint() {$/;"	f	struct:configure.CommanderConfig
WaitAdd	pkg/helper/tester.go	/^func (tc *TesterConfig) WaitAdd() {$/;"	f	struct:helper.TesterConfig
WaitCount	pkg/helper/tester.go	/^	WaitCount       int$/;"	m	struct:helper.TesterConfig	typeref:typename:int
WaitDone	pkg/helper/tester.go	/^func (tc *TesterConfig) WaitDone() {$/;"	f	struct:helper.TesterConfig
WaitForSignal	pkg/helper/tester.go	/^func (tc *TesterConfig) WaitForSignal() {$/;"	f	struct:helper.TesterConfig
WaitGroup	pkg/helper/tester.go	/^	WaitGroup       *sync.WaitGroup$/;"	m	struct:helper.TesterConfig	typeref:typename:*sync.WaitGroup
Wrap	pkg/helper/erragregate.go	/^func (er *Errw) Wrap(formatString string, a ...any) (ret error) {$/;"	f	struct:helper.Errw	typeref:typename:(ret error)
XLSXopenFile	pkg/files/xlsx.go	/^func XLSXopenFile($/;"	f	package:files	typeref:typename:(*excelize.File, func(*excelize.File), error)
XLSXtableBuild	pkg/files/xlsx.go	/^func XLSXtableBuild(filePath string) error {$/;"	f	package:files	typeref:typename:error
XLSXtableStreamSave	pkg/files/xlsx.go	/^func XLSXtableStreamSave(filePath string) error {$/;"	f	package:files	typeref:typename:error
XMLgetBaseNode	pkg/files/xml.go	/^func XMLgetBaseNode(reader io.Reader, nodePath string) (*xmlquery.Node, error) {$/;"	f	package:files	typeref:typename:(*xmlquery.Node, error)
XMLgetBaseNodes	pkg/files/xml.go	/^func XMLgetBaseNodes($/;"	f	package:files	typeref:typename:([]*xmlquery.Node, error)
XMLnodeLevelUp	pkg/files/xml.go	/^func XMLnodeLevelUp(node *xmlquery.Node, levelUp int) (*xmlquery.Node, int) {$/;"	f	package:files	typeref:typename:(*xmlquery.Node, int)
XMLprint	pkg/helper/string.go	/^func XMLprint(node *xmlquery.Node) {$/;"	f	package:helper
XOR	pkg/helper/helper.go	/^func XOR(a, b bool) bool {$/;"	f	package:helper	typeref:typename:bool
addNew	pkg/helper/erragregate.go	/^func (er *Errw) addNew(err error, params ...any) {$/;"	f	struct:helper.Errw
c	test/pkg/configure_mapany/cmd/dummy.go	/^	c "github.com\/triopium\/go_utils\/pkg\/configure"$/;"	P	package:github.com/triopium/go_utils/pkg/configure
cmd	test/pkg/configure_map/cmd/dummy.go	/^package cmd$/;"	p
cmd	test/pkg/configure_map/cmd/root.go	/^package cmd$/;"	p
cmd	test/pkg/configure_mapany/cmd/dummy.go	/^package cmd$/;"	p
cmd	test/pkg/configure_mapany/cmd/root.go	/^package cmd$/;"	p
commandDummyConfig	test/pkg/configure_map/cmd/dummy.go	/^var commandDummyConfig = configure.CommandConfig{}$/;"	v	package:cmd
commandDummyConfigure	test/pkg/configure_map/cmd/dummy.go	/^func commandDummyConfigure() {$/;"	f	package:cmd
commandDummyVars	test/pkg/configure_map/cmd/dummy.go	/^type commandDummyVars struct {$/;"	s	package:cmd
commandDummyVars	test/pkg/configure_mapany/cmd/dummy.go	/^type commandDummyVars struct {$/;"	s	package:cmd
commandRootConfig	test/pkg/configure_map/cmd/root.go	/^var commandRootConfig = configure.CommandConfig{}$/;"	v	package:cmd
commandRootConfig	test/pkg/configure_mapany/cmd/root.go	/^var commandRootConfig = configure.CommanderRoot$/;"	v	package:cmd
commanderDummyConfig	test/pkg/configure_mapany/cmd/dummy.go	/^var commanderDummyConfig = c.CommanderConfig{}$/;"	v	package:cmd
commanderDummyConfigure	test/pkg/configure_mapany/cmd/dummy.go	/^func commanderDummyConfigure() {$/;"	f	package:cmd
configure	pkg/configure/common.go	/^package configure$/;"	p
configure	pkg/configure/config_map.go	/^package configure$/;"	p
configure	pkg/configure/config_mapany.go	/^package configure$/;"	p
configure	pkg/configure/config_option_add.go	/^package configure$/;"	p
configure	pkg/configure/config_option_flag.go	/^package configure$/;"	p
configure	pkg/configure/config_option_parse.go	/^package configure$/;"	p
configure	pkg/configure/config_struct.go	/^package configure$/;"	p
configure	pkg/configure/populate.go	/^package configure$/;"	p
configure	pkg/configure/populate2.go	/^package configure$/;"	p
configure	pkg/configure/populate3.go	/^package configure$/;"	p
configure	pkg/configure/populate4.go	/^package configure$/;"	p
configure	pkg/configure/populate5.go	/^package configure$/;"	p
currentDir	pkg/helper/tester.go	/^	currentDir      string$/;"	m	struct:helper.TesterConfig	typeref:typename:string
debug	pkg/configure/populate4.go	/^var debug bool \/\/ Global debug mode$/;"	v	package:configure	typeref:typename:bool
enc_unicode	pkg/helper/file.go	/^	enc_unicode "golang.org\/x\/text\/encoding\/unicode"$/;"	P	package:golang.org/x/text/encoding/unicode
err1	test/pkg/helper/errlist.go	/^var err1 = fmt.Errorf("test error")$/;"	v	package:main
failed	pkg/helper/tester.go	/^	failed          bool$/;"	m	struct:helper.TesterConfig	typeref:typename:bool
files	pkg/files/csv.go	/^package files$/;"	p
files	pkg/files/csv_test.go	/^package files$/;"	p
files	pkg/files/xlsx.go	/^package files$/;"	p
files	pkg/files/xlsx_test.go	/^package files$/;"	p
files	pkg/files/xml.go	/^package files$/;"	p
files	pkg/files/xml_test.go	/^package files$/;"	p
go.work	README.md	/^go.work$/;"	s	chapter:Go Utils
handle_error_prefix	pkg/helper/errlist.go	/^	handle_error_prefix string = "handle_error"$/;"	c	package:helper	typeref:typename:string
helper	pkg/helper/directory.go	/^package helper$/;"	p
helper	pkg/helper/directory_test.go	/^package helper$/;"	p
helper	pkg/helper/erragregate.go	/^package helper$/;"	p
helper	pkg/helper/erragregate_test.go	/^package helper$/;"	p
helper	pkg/helper/errlist.go	/^package helper$/;"	p
helper	pkg/helper/errmap.go	/^package helper$/;"	p
helper	pkg/helper/errmap_test.go	/^package helper$/;"	p
helper	pkg/helper/errors.go	/^package helper$/;"	p
helper	pkg/helper/errors_test.go	/^package helper$/;"	p
helper	pkg/helper/file.go	/^package helper$/;"	p
helper	pkg/helper/file_test.go	/^package helper$/;"	p
helper	pkg/helper/generic.go	/^package helper$/;"	p
helper	pkg/helper/generic_test.go	/^package helper$/;"	p
helper	pkg/helper/helper.go	/^package helper$/;"	p
helper	pkg/helper/helper_test.go	/^package helper$/;"	p
helper	pkg/helper/new.go	/^package helper$/;"	p
helper	pkg/helper/slice.go	/^package helper$/;"	p
helper	pkg/helper/slice_test.go	/^package helper$/;"	p
helper	pkg/helper/string.go	/^package helper$/;"	p
helper	pkg/helper/string_test.go	/^package helper$/;"	p
helper	pkg/helper/tester.go	/^package helper$/;"	p
helper	pkg/helper/tester_test.go	/^package helper$/;"	p
helper	pkg/helper/time.go	/^package helper$/;"	p
helper	pkg/helper/time_test.go	/^package helper$/;"	p
initializedMain	pkg/helper/tester.go	/^	initializedMain bool$/;"	m	struct:helper.TesterConfig	typeref:typename:bool
initializedTemp	pkg/helper/tester.go	/^	initializedTemp bool$/;"	m	struct:helper.TesterConfig	typeref:typename:bool
loadConfigFile	pkg/configure/populate4.go	/^func loadConfigFile(cfg interface{}) {$/;"	f	package:configure
logSet	pkg/configure/populate4.go	/^func logSet(field, value, source string) {$/;"	f	package:configure
logging	pkg/logging/sloger.go	/^package logging$/;"	p
main	test/pkg/configure_map/main.go	/^func main() {$/;"	f	package:main
main	test/pkg/configure_map/main.go	/^package main$/;"	p
main	test/pkg/configure_map/main_test.go	/^package main$/;"	p
main	test/pkg/configure_mapany/main.go	/^func main() {$/;"	f	package:main
main	test/pkg/configure_mapany/main.go	/^package main$/;"	p
main	test/pkg/helper/errlist.go	/^func main() {$/;"	f	package:main
main	test/pkg/helper/errlist.go	/^package main$/;"	p
setField	pkg/configure/populate4.go	/^func setField(field reflect.Value, value string) {$/;"	f	package:configure
sigChan	pkg/helper/tester.go	/^	sigChan         chan os.Signal$/;"	m	struct:helper.TesterConfig	typeref:typename:chan os.Signal
testType	pkg/helper/tester.go	/^	testType        string$/;"	m	struct:helper.TesterConfig	typeref:typename:string
testerConfig	pkg/helper/tester_test.go	/^var testerConfig = TesterConfig{$/;"	v	package:helper
toUpperSnakeCase	pkg/configure/populate4.go	/^func toUpperSnakeCase(input string) string {$/;"	f	package:configure	typeref:typename:string
